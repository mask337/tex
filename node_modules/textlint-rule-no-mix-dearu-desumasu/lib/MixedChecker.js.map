{"version":3,"sources":["../src/MixedChecker.js"],"names":["MixedChecker","context","options","dearuCount","desumasuCount","dearuHitList","desumasuHitList","_queue","Promise","resolve","node","text","then","analyzeOptions","ignoreConjunction","isStrict","results","retDearu","filter","isDearu","retDesumasu","isDesumasu","length","push","matches","ignoreManger","isOver","RuleError","report","overType","getOverType","overHitList","forEach","lastHitNode","token","hitIndex","range","index","isIgnoredIndex","ruleError","outputMessage","preferDearu","preferDesumasu","value"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { analyze, isDearu, isDesumasu } from \"analyze-desumasu-dearu\";\nexport default class MixedChecker {\n    /**\n     * @param context\n     * @param {{preferDearu:boolean, preferDesumasu: boolean}} options\n     */\n    constructor(context, options) {\n        this.context = context;\n        /**\n         * 明示的な優先するタイプの指定\n         * @type {{preferDearu: boolean, preferDesumasu: boolean, isStrict: boolean}}\n         */\n        this.options = options;\n        this.dearuCount = 0;\n        this.desumasuCount = 0;\n        this.dearuHitList = [];\n        this.desumasuHitList = [];\n        this._queue = Promise.resolve();\n    }\n\n    check(node, text) {\n        this._queue = this._queue.then(() => {\n            const analyzeOptions = {\n                ignoreConjunction: !this.options.isStrict\n            };\n            return analyze(text, analyzeOptions).then(results => {\n                const retDearu = results.filter(isDearu);\n                const retDesumasu = results.filter(isDesumasu);\n                const dearuCount = this.dearuCount + retDearu.length;\n                const desumasuCount = this.desumasuCount + retDesumasu.length;\n                if (this.dearuCount !== dearuCount) {\n                    this.dearuCount = dearuCount;\n                    this.dearuHitList.push({\n                        node,\n                        matches: retDearu\n                    });\n                }\n                if (this.desumasuCount !== desumasuCount) {\n                    this.desumasuCount = desumasuCount;\n                    this.desumasuHitList.push({\n                        node,\n                        matches: retDesumasu\n                    });\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {IgnoreManger}ignoreManger\n     * @returns {Promise.<TResult>}\n     */\n    checkout(ignoreManger) {\n        return this._queue.then(() => {\n            if (!this.isOver()) {\n                return;\n            }\n            const RuleError = this.context.RuleError;\n            const report = this.context.report;\n            const overType = this.getOverType();\n            const overHitList = this.overHitList(overType);\n            // List\n            overHitList.forEach(({ node, matches }) => {\n                // Node\n                const lastHitNode = node;\n                // Tokens\n                matches.forEach(token => {\n                    const hitIndex = node.range[0] + token.index;\n                    if (ignoreManger.isIgnoredIndex(hitIndex)) {\n                        return;\n                    }\n\n                    const ruleError = new RuleError(this.outputMessage(token), {\n                        index: token.index\n                    });\n                    report(lastHitNode, ruleError);\n                });\n            });\n        });\n    }\n\n    isOver() {\n        return this.dearuCount !== 0 && this.desumasuCount !== 0;\n    }\n\n    /**\n     * 優先するtypeを返します。\n     * @returns {*}\n     */\n    getOverType() {\n        if (this.options.preferDearu) {\n            return \"である\";\n        } else if (this.options.preferDesumasu) {\n            return \"ですます\";\n        }\n        if (this.dearuCount > this.desumasuCount) {\n            return \"である\";\n        } else {\n            return \"ですます\";\n        }\n    }\n\n    /**\n     * hist node list\n     * @param overType\n     * @returns {Array}\n     */\n    overHitList(overType) {\n        if (overType === \"である\") {\n            return this.desumasuHitList;\n        } else if (overType === \"ですます\") {\n            return this.dearuHitList;\n        }\n    }\n\n    /**\n     * create message string\n     * @param token\n     * @returns {string}\n     */\n    outputMessage(token) {\n        const overType = this.getOverType();\n        if (overType === \"である\") {\n            // である優先 => 最後の\"ですます\"を表示\n            return `\"である\"調 と \"ですます\"調 が混在\n=> \"${token.value}\" がですます調\nTotal:\nである  : ${this.dearuCount}\nですます: ${this.desumasuCount}\n`;\n        } else if (overType === \"ですます\") {\n            // ですます優先 => 最後の\"である\"を表示\n            return `\"である\"調 と \"ですます\"調 が混在\n=> \"${token.value}\" がである調\nTotal:\nである  : ${this.dearuCount}\nですます: ${this.desumasuCount}\n`;\n        }\n    }\n}\n"],"file":"MixedChecker.js"}