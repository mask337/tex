// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MessageType_1 = require("../shared/type/MessageType");
/**
 * the `index` is in the `range` and return true.
 * @param {Number} index
 * @param {Number[]} range
 * @returns {boolean}
 */
var isContainedRange = function (index, range) {
    var start = range[0], end = range[1];
    return start <= index && index <= end;
};
// TODO: share code
// @org/preset/@org/rule
var patternOrgXOrg = /^(@.*?\/.*?)\/(@.*?\/.*?)$/;
// @org/preset/rule
var patternOrgXRule = /^(@.*?\/.*?)\/(.*?)$/;
// preset/@org/rule
var patternPresetXOrg = /^(.*?)\/(@.*?)$/;
// preset/rule
var patternPresetXRule = /^([^@].*?)\/(.*?)$/;
/**
 * split "preset/rule" string to {preset, rule}
 */
exports.splitKeyToPresetSubRule = function (name) {
    var patternList = [patternOrgXOrg, patternOrgXRule, patternPresetXOrg, patternPresetXRule];
    for (var i = 0; i < patternList.length; i++) {
        var pattern = patternList[i];
        var result = name.match(pattern);
        if (!result) {
            continue;
        }
        return { preset: result[1], rule: result[2] };
    }
    // Other case is a single rule
    // @org/rule or rule
    return {
        preset: null,
        rule: name
    };
};
/**
 * normalize `keyPath` that is specific path for rule
 * This normalize function handle ambiguity `key`
 * `keyPath` is one of "preset/rule` key, or "rule" key
 * @param keyPath
 */
exports.normalizeKeyPath = function (keyPath) {
    var _a = exports.splitKeyToPresetSubRule(keyPath), preset = _a.preset, rule = _a.rule;
    if (!preset) {
        return exports.normalizeRuleKey(rule);
    }
    return exports.normalizeRulePresetKey(preset) + "/" + exports.normalizeRuleKey(rule);
};
exports.normalizeRuleKey = function (name) {
    return exports.removePrefixFromPackageName(["textlint-rule-"], name);
};
exports.normalizeRulePresetKey = function (name) {
    return exports.removePrefixFromPackageName(["textlint-rule-preset-", "preset-"], name);
};
/**
 * Remove `prefix` from `text`.
 */
exports.removePrefixFromPackageName = function (prefixList, packageName) {
    for (var i = 0; i < prefixList.length; i++) {
        var prefix = prefixList[i];
        // @scope/name -> @scope/name
        // @scope/textlint-rule-name -> @scope/name
        if (packageName.charAt(0) === "@") {
            var _a = packageName.split("/"), namespace = _a[0], name_1 = _a[1];
            if (name_1.startsWith(prefix)) {
                return namespace + "/" + name_1.slice(prefix.length);
            }
        }
        // name -> name
        // textlint-rule-name -> name
        else if (packageName.startsWith(prefix)) {
            return packageName.slice(prefix.length);
        }
    }
    // No match
    return packageName;
};
/**
 * filter messages by ignore messages
 * @param {Object[]} messages
 * @returns {Object[]} filtered messages
 */
function filterMessages(messages) {
    if (messages === void 0) { messages = []; }
    var lintingMessages = messages.filter(function (message) {
        return message.type === MessageType_1.default.lint;
    });
    var ignoreMessages = messages.filter(function (message) {
        return message.type === MessageType_1.default.ignore;
    });
    // if match, reject the message
    return lintingMessages.filter(function (message) {
        return !ignoreMessages.some(function (ignoreMessage) {
            var isInIgnoringRange = isContainedRange(message.index, ignoreMessage.range);
            if (isInIgnoringRange && ignoreMessage.ignoringRuleId) {
                // "*" is wildcard that match any rule
                if (ignoreMessage.ignoringRuleId === "*") {
                    return true;
                }
                return message.ruleId === exports.normalizeKeyPath(ignoreMessage.ignoringRuleId);
            }
            return isInIgnoringRange;
        });
    });
}
exports.default = filterMessages;
//# sourceMappingURL=filter-ignored-process.js.map